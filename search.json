[{"title":"青铜教程第五课——树结构","path":"/2020/11/24/青铜教程第五课——树结构/","content":"大家好，这里是轮回，欢迎来到我的青铜教程第五课——实体层级讲解。 本节课的目标 初识树结构，掌握父、子实体关系的概念 学习临时实体箱的使用 学习合成器与分解器的基础使用 特别感谢​ 感谢FlexSim中国总代理北京创时能支持提供的一段时间的教育版账号。同时在此声明，本课程是由本人独立制作并拥有完整版权。 初识树结构如果说Model视图中的动画是“外形”，那么树结构就是FlexSim仿真的“骨架”。 ​ 在FlexSim中，树结构是整个模型的框架，目前只能在正式版打开。我们首先来学习右侧树导航中排第一模型树。模型树中主要是描述各个实体的层级关系和相关属性变量、状态。那么我们创建的各种实体，会按照先后顺序添加到model下（并且会给出编号）。可以通过下图工具修改 ​ Tools则是代表工具箱中的相关变量和实体，目前我的搭档小付同学已经做了两期分别关于全局表和列表相关的东西，大家可以去看一看。 ​ 默认FlexSim会给我们创建一个FlexSimModelFloor的实体，方便我们后续在3D界面创建实体。每个实体点击会显示下面的一些子节点： ​ 我们进行一个迅速地简单浏览，就可以发现我们之前讲述的标签 labels 也是拥有一个treenode节点的。 superclasses —— 基类，了解即可 classes —— 实体的当前类型，了解即可 variables ——实体变量节点，非常的重要 behaviour —— 实体行为节点，暂时不需要了解 stats —— 统计各种实体状态持续时间和一些常用统计变量 special —— 实体的一些相关说明 visual —— 可视化节点，包含3d实体外观和图片材质属性 spatial —— 空间节点，记录实体的位置、旋转、大小等属性 objectinfo —— 实体信息，根据不同实体会记录统计一些人们关注的统计值 windowtitle —— 窗口说明，不重要 labels —— 标签节点，非常重要，保存实体拥有的标签 connections —— 连接节点，包含输入、输出、中间节点 events —— 事件节点，和消息触发有关 stored —— 没用到过 ​ 在模型运行过程中，临时实体会在固定资源实体和任务执行器实体中流转，最终被吸收器吸收，这也正是前面第二课我们讲过临时实体为什么临时。 ​ 我们再来看树导航中的第二个视图——主树，我们上节课中讲到了仿真软件的一个机制——下一最早事件的推进的案例中，在exec中的events就得到了体现，我们来复习一下。首先，events代表事件表，它包含下一次每类事件发生的表，在events目录下，每次都是由库例程计算事件的发生时间，然后当某一特定类型事件发生时更新系统状态的子程序（每类事件都有一个事件例程），如此往复。我们点击Step步进就会清楚的了解到这一仿真机制在仿真软件扮演了一个非常重要的角色，那么如果你没有看过或者忘记了，记得去看第四课的青铜教程哦！ ​ 对于树结构我们先了解到这，后续我们会伴随课程继续以案例讲解。 父子实体关系​ 那么刚才在模型运转过程中，临时实体其实是在各个实体中流转，那么在某一时刻，暂存区内有2个实体在排队，在树结构中，我们也能看到暂存区中有两个BOX实体。 ​ 我们称这两个BOX此时是暂存求3的两个子实体，而暂存区是这两个BOX的父实体。 世界坐标、相对坐标、自身坐标父子实体的坐标关系当形成了父子实体的关系之后，父实体进行移动和旋转操作，子实体也会进行对应的移动、旋转操作。 应用 实体进入时指定位置，指定打包规则 控制实体运动的轨迹，自定义实体运动学 Vec3类型123456Vec3 globalLoc = Vec3(5, 3, 0).project(current, model());// Vec3.project()// Vec3 project( treenode from , treenode to )// 将向量从一个坐标空间转换到另一个坐标空间。// 原理是线性代数 实体的层级​ 在生产过程中，我们通常会使用用托盘或者纸盒作为包装来装货，这些托盘和纸箱实际上在扮演着临时实体的容器类实体，一般的临时实体，比如BOX等，通常会放在容器类实体中。在FlexSim中，我们可以在临时实体工具箱中找到这类实体。这些实体在模型运行中扮演了重要的作用。 在模型运行过程中，大致的基本实体层级如下： 固定资源实体/任务执行器类实体——&gt; 容器类实体——&gt; 一般临时实体 学习了实体层级之后，我们再来学习实体的图形帧用法，学习这个概念我们直接通过一个可乐灌装案例来学习吧 图形帧图形帧的添加非常简单，如下图： 添加之后，我们就可以看到 在这我们就能替换掉当前实体的外观了。我们按照同理可以添加实体的很多图形帧 可乐案例打开我制作好的三个Sketch up模型，分别为可乐的三种状态，一个空瓶状态，一个灌装饮料的空瓶状态，另外一个是装好瓶盖贴上贴纸后完整的可乐。我们来添加可乐这一临时实体吧。"},{"title":"青铜教程第四课——仿真机制讲解","path":"/2020/11/24/青铜教程第四课——仿真机制讲解/","content":"大家好，这里是轮回，欢迎来到我的青铜教程第四课——仿真机制讲解。 导读本节课将主要讲述仿真模型运行的基本机制，通过对本节课的学习，你将会明白离散型仿真软件的运作原理，更好地了解 触发器与事件的联系。 什么是事件调动型仿真仿真钟在讲述这个问题之前，我们先来认识一下一个所有仿真软件都有的东西，那就是仿真钟。 仿真钟是 用来 记录跟踪 随着仿真的动态进行过程中 的时间变量。 那么在FlexSim里对应的就是： 那么仿真钟有以下性质： 通常和计算机计算所花费的实际时间无关 其单位通常需要明确指出 仿真钟和实际时钟的关系不同可以划分为下面三种： 实时仿真 —— 运行速度=1 等于1s 欠实时仿真 —— 运行速度&lt;1 超实时仿真 —— 运行速度&gt;1 事件时间推进机制仿真钟的推进机制通常有两种： 下一最早发生事件时间的推进 固定增量时间的推进 在这里，计算机软件中通常使用第一种方式，第二种方式可以认为是第一种的特例，在讲完第一种方式我会再简单讲述一下第二种。那我们先来了解一下第一种方式： ​ 对于第一种推进机制，首先，仿真钟初始化为0，且将来事件的发生时间是确定的。然后，仿真钟将被推进到这些将来事件中最早要发生的（第一个）事件的发生时间，紧接着系统的状态更新，也将印证着这一事件的发生，且相关将来事件的发生时间也将被更新。接下来，仿真钟也将被同样推进到下一个最早要发生的事件，更新系统的状态和未来事件的发生时间。 例子__单服务台排队系统 先决条件：上面所有变量均为独立的随机变量，服从随机分布。那么这些随机分布在FlexSim中也是非常常见的。 诸如： 在这类比一下，假设发生器的到达时间间隔服从$F_A$，处理器的加工时间服从$F_S$ Step1 : 在$e_0=0$的时刻，服务台为空闲。由服务台状态为空闲。由$F_A$产生$A_1$，并将其加到时间轴的0上，则确定了第一个到达时间$t_1$。 $e_1$事件描述：发生器产生第一个临时实体到达暂存区。 Step2：仿真钟从$e_0$推进到下一（第一个）时间发生的时间$e_1=t_1$。此刻，顾客发现服务台空闲，服务台立即进入服务。因此此时延迟（Delay）时间$D = 0$，服务台状态由空闲变为忙碌。该到达的顾客完成服务离开的时间$c_1$由$F_S$所产生的$S_1$并将其加$t_1$计算得到。 $e_2$事件描述：第一个临时实体进入处理器，同时计算得到第二个临时实体的到达时间 Step3：紧接着，第二个到达时间$t_2$由$t_2 = t_1 + A_2$计算而得，$A_2$也是按照分布$F_A$生成。 Step4：如果$t_2&lt;c_1$，仿真钟将会推进到下一最早事件的发生时间$e_2=t_2$，此时第二个顾客将会等待第一个顾客结束服务，在暂存区排队等待，等待的人数由0增加到1，同时记录第二个顾客到达的时间。 如果$t_2&gt;c_1$，仿真钟将会推进到下一最早事件的发生时间$e_2=c_1$。 Step5 : 类似地，第三个达到时间$t_3$由$t_3 = t_2 + A_3$计算而得。如果$c_1 &lt; t_3$，仿真钟将从$e_2$推进到下一事件$e_3=c_1$，即第一位顾客完成服务离开的时间，同时队列中的顾客（$t_2$到达的顾客）开始被被服务，其队列中的延误时间$D_2 = c_1-t_2$ 与服务完成时间$c_2=c_1+S_2$确定，队列中的顾客由1减少为0. 后续依次类推…. 仿真软件的架构组成那么在了解上面这个机制之后，我们来分析一下仿真软件的组成 系统状态：描述在某一特定时刻系统所必需的一组状态变量的集合 比如 服务台的空闲还是忙碌 仿真钟：给出仿真时间当前值的变量 事件表：包含下一次每类事件发生的表 统计计数器：用于存储系统性能统计信息的变量 初始化例程：零时刻对仿真模型进行初始化的子程序 举例：重置触发 事件例程：当某一特定类型事件发生时更新系统状态的子程序（每类事件都有一个事件例程） 库例程：一般是作为辅助工具，用于根据概率统计分布生成随机值的程序。 报告生成器：计算系统性能的期望值，并生成一个仿真报告 主程序：调用定时例程来确定下一事件，然后控制转移到相应的事件例程以适当更新系统状态 那么基本的运行流程图如下： 事件的进程拆分机制我们学习完事件调度的方式后，其实你类比于FlexSim中的到达时间间隔和处理加工时间，其实已经会略有所悟。 但是仍然会发现目前这个机制对于模型的可操控性还不够强，不能实现一些高级的逻辑要求。 其实大部分仿真软件是在之前事件调度的机制之上，使用了事件的进程拆分机制。 那么什么是进程拆分机制呢？ 我们先来讲述进程的概念，进程使用时间区间来分隔的有时序的互相关联的事件序列，它可以描述一个 “ 临时实体 ”流经 “ 系统 ”的完整过程。 请参考微信公众号上描述 结尾后续我和小付同学会将每节课的案例或者相关资料讲解更新到这个微信公众号上，大家可以关注方便获取哦！","tags":["青铜教程"]},{"title":"Hexo新坑","path":"/2020/10/17/hexo新坑/","content":"Hexo新坑使用Day1基本目录： .deploy_git: git发布插件 node_modules: nodejs的渲染插件 public: 发布版文件，发布到服务器上的。 scaffolds: 模板文件，修改模板 source : 你的源文件，_post是要发布的 themes : 主题文件夹 写博客开一个新坑 1hexo new &quot;文章标题&quot; 开始编辑 —— 支持markdown语法 编辑完成后 1hexo g 再启动服务 1hexo s font-matter123456789---title: hexo新坑date: 2020-10-17 17:25:04tags:category: - 1 - 2--- 使用模板创建一个草稿1hexo new draft &quot;标题&quot; 不会被hexo加入渲染 创建一个页面1hexo new page &quot;标题&quot; 添加自定义模板1在scaffolds中创建你的模板文件，比如文件名是srxpage，然后 hexo new srxpage &quot;标题&quot;","tags":["Hexo"]},{"path":"/css/mytest.css","content":".card-announcement .social-button a { display: block; background-color: rgb(73 177 245); color: rgb(255 255 255); line-height: 1.6rem; transition: all .3s; position: relative; z-index: 1; } .card-announcement .social-button { margin: .6rem 0 0 0; text-align: center; }"}]